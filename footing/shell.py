from __future__ import annotations

import contextlib
import os
import pathlib
import shlex
import shutil
import signal
import subprocess
import sys
import tempfile
import textwrap
from typing import Any

import pexpect
from shellingham import detect_shell, ShellDetectionFailure

import footing.util

WINDOWS = sys.platform == "win32"


@contextlib.contextmanager
def temp_environ():
    environ = dict(os.environ)
    try:
        yield
    finally:
        os.environ.clear()
        os.environ.update(environ)


class Shell:
    """
    Represents the current shell.
    """

    _shell = None

    def __init__(self, name: str, path: str) -> None:
        self._name = name
        self._path = path

    @property
    def name(self) -> str:
        return self._name

    @property
    def path(self) -> str:
        return self._path

    @classmethod
    def get(cls) -> Shell:
        """
        Retrieve the current shell.
        """
        if cls._shell is not None:
            return cls._shell

        try:
            name, path = detect_shell(os.getpid())
        except (RuntimeError, ShellDetectionFailure):
            shell = None

            if os.name == "posix":
                shell = os.environ.get("SHELL")
            elif os.name == "nt":
                shell = os.environ.get("COMSPEC")

            if not shell:
                raise RuntimeError("Unable to detect the current shell.")

            name, path = pathlib.Path(shell).stem, shell

        cls._shell = cls(name, path)

        return cls._shell

    def get_setup_script(self):
        conda_dir = footing.util.conda_dir()

        if self.name in ("posix", "ash", "bash", "dash", "zsh"):
            return textwrap.dedent(
                f"""
                __conda_setup="$('{conda_dir}/bin/conda' 'shell.{self.name}' 'hook' 2> /dev/null)"
                if [ $? -eq 0 ]; then
                    eval "$__conda_setup"
                else
                    if [ -f "{conda_dir}/etc/profile.d/conda.sh" ]; then
                        . "{conda_dir}/etc/profile.d/conda.sh"
                    else
                        export PATH="{conda_dir}/bin:$PATH"
                    fi
                fi
                unset __conda_setup

                if [ -f "{conda_dir}/etc/profile.d/mamba.sh" ]; then
                    . "{conda_dir}/etc/profile.d/mamba.sh"
                fi

                __footing_exe() (
                    \\local FOOTING_EXE=$(\\dirname "${{CONDA_EXE}}")/footing
                    "$FOOTING_EXE" "$@"
                )

                footing() {{
                    \\local cmd1="${{1-__missing__}}"
                    \\local cmd2="${{2-__missing__}}"
                    if [ $cmd1 == "set" ] || [ $cmd1 == "unset" ] || [ $cmd1 == "activate" ]
                    then
                        if [ $cmd1 == "set" ] || [ $cmd1 == "unset" ]
                        then
                            __footing_exe "$@"
                        fi

                        __conda_activate deactivate
                        \\local conda_env_name=$(_FOOTING_ACTIVATE=1 __footing_exe activate)
                        if [ ! -z $conda_env_name ]
                        then
                            __conda_activate activate $conda_env_name
                        fi
                    elif [ $cmd1 == "deactivate" ]
                    then
                        __conda_activate deactivate
                    elif [ $cmd1 == "sync" ] || [ $cmd2 == "sync" ]
                    then
                        __footing_exe "$@"
                        __conda_reactivate
                    else
                        __footing_exe "$@"
                    fi
                }}

                export MAMBA_NO_BANNER=1
                export FOOTING_SHELL=1
                __conda_activate deactivate
                _FOOTING_ACTIVATE=1 footing activate || true
                """
            )
        elif self.name == "fish":
            return textwrap.dedent(
                f"""
                eval {conda_dir}/bin/conda "shell.fish" "hook" $argv | source

                if test -f "{conda_dir}/etc/fish/conf.d/mamba.fish"
                    source "{conda_dir}/etc/fish/conf.d/mamba.fish"
                end
                """
            )
        elif self.name == "xonsh":
            return textwrap.dedent(
                f"""
                import sys as _sys
                from types import ModuleType as _ModuleType
                _mod = _ModuleType("xontrib.conda",
                                   "Autogenerated from $({conda_dir}/bin/conda shell.xonsh hook)")
                __xonsh__.execer.exec($("{conda_dir}/bin/conda" "shell.xonsh" "hook"),
                                      glbs=_mod.__dict__,
                                      filename="$({conda_dir}/bin/conda shell.xonsh hook)")
                _sys.modules["xontrib.conda"] = _mod
                del _sys, _mod, _ModuleType
                """
            )
        elif self.name in ("csh", "tcsh"):
            return textwrap.dedent(
                f"""
                if ( -f "{conda_dir}/etc/profile.d/conda.csh" ) then
                    source "{conda_dir}/etc/profile.d/conda.csh"
                else
                    setenv PATH "{conda_dir}/bin:$PATH"
                endif

                if [ -f "{conda_dir}/etc/profile.d/mamba.sh" ]; then
                    . "{conda_dir}/etc/profile.d/mamba.sh"
                fi
                """
            )
        else:
            raise ValueError(f"Shell {self.name} not supported")

    def init(self) -> int | None:
        if os.environ.get("FOOTING_SHELL"):
            return

        with tempfile.NamedTemporaryFile() as setup_script_file:
            setup_script_file.write(self.get_setup_script().encode("utf-8"))
            setup_script_file.flush()
            setup_script_path = setup_script_file.name

            # mypy requires using sys.platform instead of WINDOWS constant
            # in if statements to properly type check on Windows
            if sys.platform == "win32":
                args = None
                if self._name in ("powershell", "pwsh"):
                    args = ["-NoExit", "-File", str(setup_script_path)]
                elif self._name == "cmd":
                    # /K will execute the bat file and
                    # keep the cmd process from terminating
                    args = ["/K", str(setup_script_path)]

                if args:
                    completed_proc = subprocess.run([self.path, *args])
                    return completed_proc.returncode
                else:
                    # TODO: Poetry supports this use case, but it's not certain which
                    # shell causes this condition
                    raise ValueError(f"Shell {self._name} not supported")

            terminal = shutil.get_terminal_size()
            with temp_environ():
                c = pexpect.spawn(
                    self._path, ["-i"], dimensions=(terminal.lines, terminal.columns)
                )

            if self._name in ["zsh", "nu"]:
                c.setecho(False)
                if self._name == "zsh":
                    # Under ZSH the source command should be invoked in zsh's bash emulator
                    c.sendline(
                        f"emulate bash -c '. {shlex.quote(str(setup_script_path))}'"
                        " && clear && footing --banner"
                    )
            else:
                c.sendline(
                    f"{self._get_source_command()} {shlex.quote(str(setup_script_path))}"
                    " && clear && footing --banner"
                )

            def resize(sig: Any, data: Any) -> None:
                terminal = shutil.get_terminal_size()
                c.setwinsize(terminal.lines, terminal.columns)

            signal.signal(signal.SIGWINCH, resize)

            # Interact with the new shell.
            c.interact(escape_character=None)
            c.close()

            sys.exit(c.exitstatus)

    def _get_source_command(self) -> str:
        if self._name in ("fish", "csh", "tcsh", "nu"):
            return "source"
        return "."

    def __repr__(self) -> str:
        return f'{self.__class__.__name__}("{self._name}", "{self._path}")'
